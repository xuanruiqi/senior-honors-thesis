All code written for this thesis is open-sourced and publicly available on GitHub.

\section{The red-black tree benchmark}
The red-black tree benchmark is a simple benchmark used to investigate and benchmark behavior in functional programming
systems and runtime systems. The benchmark has been ported to four languages: Scala, Haskell, Standard ML, and OCaml. We
used the four ports to benchmark four runtime systems: the HotSpot JVM \& Oracle JDK, the Glasgow Haskell Compiler (GHC),
MLton, and the INRIA reference OCaml implementation, respectively.

The red-black tree benchmark consists of three tasks: inserting one million numbers (the integers 1 to 1,000,000) into
an empty red-black tree, printing the height of the red-black tree, and then in-order traversing the red-black tree. The
implementation of the red-black tree is based on \cite{PFDS}'s purely functional implementation.

For code and build instructions, please visit: ~\url{https://github.com/ElephantTracksProject/rbtbench}.

\section{The Java micro-benchmark suite}
The Java micro-benchmark suite is intended to benchmark the Java frontend to Elephant Tracks 2. It consists of the
following benchmarks, the first five of which are written in Java and the latter two written in Scala:
\begin{itemize}
\item \lstinline{Hello}: the ``Hello, world!'' program;
\item \lstinline{BF}: implements an interpreter for an esoteric, minimal programming language;
\item \lstinline{BinarySearchTree}: builds two standard, imperative binary search trees, inserts two sets of data into them,
in-order traverses them, and calculate their respective heights;
\item \lstinline{LambdaCalc}: implements a simple untyped, call-by-value $\lambda$-calculus evaluator using a simple named representation, and attempts
to $\beta$-reduce the $\lambda$-term $(\lambda x \ . \ (x \ x)) \ (\lambda y \ . \ y) \ (\lambda z \ . \ z)$.
\item \lstinline{NatArith}: implements inductive natural number arithmetic (i.e., as implemented in Coq and Idris) and
conversion between natural numbers and Java integers, and evaluates $1921 + 3385$ using the implementation;
\item \lstinline{FunctionalCounter}: implements a counter using closure capture of local variables, and invokes the counter
a large number of times;
\item \lstinline{FunctionalRBT}: the same Scala red-black tree benchmark from the red-black tree benchmark suite.
\end{itemize}

For code and build instructions, please visit: ~\url{https://github.com/ElephantTracksProject/benchmarks}.

\section{Elephant Tracks II}
ET2 is contained in multiple repositories. The Java frontend is located at: ~\url{https://github.com/ElephantTracksProject/et2-java}.
Our fork of the JNIF library, which is needed to build the Java frontend, is located at: ~\url{https://github.com/ElephantTracksProject/jnif}.
